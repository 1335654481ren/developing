// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: carmsg.proto

#ifndef PROTOBUF_carmsg_2eproto__INCLUDED
#define PROTOBUF_carmsg_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace pbcar {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_carmsg_2eproto();
void protobuf_AssignDesc_carmsg_2eproto();
void protobuf_ShutdownFile_carmsg_2eproto();

class ImageUpload;
class LocInfo;
class LocUpload;
class ServerResponse;
class ServerCmd;
class DeviceResponse;
class MessageWrapper;

// ===================================================================

class ImageUpload : public ::google::protobuf::Message {
 public:
  ImageUpload();
  virtual ~ImageUpload();

  ImageUpload(const ImageUpload& from);

  inline ImageUpload& operator=(const ImageUpload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageUpload& default_instance();

  void Swap(ImageUpload* other);

  // implements Message ----------------------------------------------

  ImageUpload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageUpload& from);
  void MergeFrom(const ImageUpload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated bytes snapshot = 1;
  inline int snapshot_size() const;
  inline void clear_snapshot();
  static const int kSnapshotFieldNumber = 1;
  inline const ::std::string& snapshot(int index) const;
  inline ::std::string* mutable_snapshot(int index);
  inline void set_snapshot(int index, const ::std::string& value);
  inline void set_snapshot(int index, const char* value);
  inline void set_snapshot(int index, const void* value, size_t size);
  inline ::std::string* add_snapshot();
  inline void add_snapshot(const ::std::string& value);
  inline void add_snapshot(const char* value);
  inline void add_snapshot(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& snapshot() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_snapshot();

  // optional uint64 timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // optional string session = 3;
  inline bool has_session() const;
  inline void clear_session();
  static const int kSessionFieldNumber = 3;
  inline const ::std::string& session() const;
  inline void set_session(const ::std::string& value);
  inline void set_session(const char* value);
  inline void set_session(const char* value, size_t size);
  inline ::std::string* mutable_session();
  inline ::std::string* release_session();
  inline void set_allocated_session(::std::string* session);

  // optional string sequence = 4;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 4;
  inline const ::std::string& sequence() const;
  inline void set_sequence(const ::std::string& value);
  inline void set_sequence(const char* value);
  inline void set_sequence(const char* value, size_t size);
  inline ::std::string* mutable_sequence();
  inline ::std::string* release_sequence();
  inline void set_allocated_sequence(::std::string* sequence);

  // @@protoc_insertion_point(class_scope:pbcar.ImageUpload)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_session();
  inline void clear_has_session();
  inline void set_has_sequence();
  inline void clear_has_sequence();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> snapshot_;
  ::google::protobuf::uint64 timestamp_;
  ::std::string* session_;
  ::std::string* sequence_;
  friend void  protobuf_AddDesc_carmsg_2eproto();
  friend void protobuf_AssignDesc_carmsg_2eproto();
  friend void protobuf_ShutdownFile_carmsg_2eproto();

  void InitAsDefaultInstance();
  static ImageUpload* default_instance_;
};
// -------------------------------------------------------------------

class LocInfo : public ::google::protobuf::Message {
 public:
  LocInfo();
  virtual ~LocInfo();

  LocInfo(const LocInfo& from);

  inline LocInfo& operator=(const LocInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocInfo& default_instance();

  void Swap(LocInfo* other);

  // implements Message ----------------------------------------------

  LocInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocInfo& from);
  void MergeFrom(const LocInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // optional float z = 3;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 3;
  inline float z() const;
  inline void set_z(float value);

  // optional float w = 4;
  inline bool has_w() const;
  inline void clear_w();
  static const int kWFieldNumber = 4;
  inline float w() const;
  inline void set_w(float value);

  // @@protoc_insertion_point(class_scope:pbcar.LocInfo)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_z();
  inline void clear_has_z();
  inline void set_has_w();
  inline void clear_has_w();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float y_;
  float z_;
  float w_;
  friend void  protobuf_AddDesc_carmsg_2eproto();
  friend void protobuf_AssignDesc_carmsg_2eproto();
  friend void protobuf_ShutdownFile_carmsg_2eproto();

  void InitAsDefaultInstance();
  static LocInfo* default_instance_;
};
// -------------------------------------------------------------------

class LocUpload : public ::google::protobuf::Message {
 public:
  LocUpload();
  virtual ~LocUpload();

  LocUpload(const LocUpload& from);

  inline LocUpload& operator=(const LocUpload& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LocUpload& default_instance();

  void Swap(LocUpload* other);

  // implements Message ----------------------------------------------

  LocUpload* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LocUpload& from);
  void MergeFrom(const LocUpload& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pbcar.LocInfo location = 1;
  inline int location_size() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 1;
  inline const ::pbcar::LocInfo& location(int index) const;
  inline ::pbcar::LocInfo* mutable_location(int index);
  inline ::pbcar::LocInfo* add_location();
  inline const ::google::protobuf::RepeatedPtrField< ::pbcar::LocInfo >&
      location() const;
  inline ::google::protobuf::RepeatedPtrField< ::pbcar::LocInfo >*
      mutable_location();

  // optional uint64 timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // optional string sequence = 3;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  inline const ::std::string& sequence() const;
  inline void set_sequence(const ::std::string& value);
  inline void set_sequence(const char* value);
  inline void set_sequence(const char* value, size_t size);
  inline ::std::string* mutable_sequence();
  inline ::std::string* release_sequence();
  inline void set_allocated_sequence(::std::string* sequence);

  // @@protoc_insertion_point(class_scope:pbcar.LocUpload)
 private:
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_sequence();
  inline void clear_has_sequence();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::pbcar::LocInfo > location_;
  ::google::protobuf::uint64 timestamp_;
  ::std::string* sequence_;
  friend void  protobuf_AddDesc_carmsg_2eproto();
  friend void protobuf_AssignDesc_carmsg_2eproto();
  friend void protobuf_ShutdownFile_carmsg_2eproto();

  void InitAsDefaultInstance();
  static LocUpload* default_instance_;
};
// -------------------------------------------------------------------

class ServerResponse : public ::google::protobuf::Message {
 public:
  ServerResponse();
  virtual ~ServerResponse();

  ServerResponse(const ServerResponse& from);

  inline ServerResponse& operator=(const ServerResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerResponse& default_instance();

  void Swap(ServerResponse* other);

  // implements Message ----------------------------------------------

  ServerResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerResponse& from);
  void MergeFrom(const ServerResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 status_code = 1;
  inline bool has_status_code() const;
  inline void clear_status_code();
  static const int kStatusCodeFieldNumber = 1;
  inline ::google::protobuf::int32 status_code() const;
  inline void set_status_code(::google::protobuf::int32 value);

  // optional string desc = 2;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 2;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional string sequence = 3;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  inline const ::std::string& sequence() const;
  inline void set_sequence(const ::std::string& value);
  inline void set_sequence(const char* value);
  inline void set_sequence(const char* value, size_t size);
  inline ::std::string* mutable_sequence();
  inline ::std::string* release_sequence();
  inline void set_allocated_sequence(::std::string* sequence);

  // @@protoc_insertion_point(class_scope:pbcar.ServerResponse)
 private:
  inline void set_has_status_code();
  inline void clear_has_status_code();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_sequence();
  inline void clear_has_sequence();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* desc_;
  ::std::string* sequence_;
  ::google::protobuf::int32 status_code_;
  friend void  protobuf_AddDesc_carmsg_2eproto();
  friend void protobuf_AssignDesc_carmsg_2eproto();
  friend void protobuf_ShutdownFile_carmsg_2eproto();

  void InitAsDefaultInstance();
  static ServerResponse* default_instance_;
};
// -------------------------------------------------------------------

class ServerCmd : public ::google::protobuf::Message {
 public:
  ServerCmd();
  virtual ~ServerCmd();

  ServerCmd(const ServerCmd& from);

  inline ServerCmd& operator=(const ServerCmd& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ServerCmd& default_instance();

  void Swap(ServerCmd* other);

  // implements Message ----------------------------------------------

  ServerCmd* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServerCmd& from);
  void MergeFrom(const ServerCmd& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 cmd = 1;
  inline bool has_cmd() const;
  inline void clear_cmd();
  static const int kCmdFieldNumber = 1;
  inline ::google::protobuf::int32 cmd() const;
  inline void set_cmd(::google::protobuf::int32 value);

  // optional uint64 timestamp = 2;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 2;
  inline ::google::protobuf::uint64 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint64 value);

  // optional .pbcar.LocInfo start_point = 3;
  inline bool has_start_point() const;
  inline void clear_start_point();
  static const int kStartPointFieldNumber = 3;
  inline const ::pbcar::LocInfo& start_point() const;
  inline ::pbcar::LocInfo* mutable_start_point();
  inline ::pbcar::LocInfo* release_start_point();
  inline void set_allocated_start_point(::pbcar::LocInfo* start_point);

  // optional .pbcar.LocInfo end_point = 4;
  inline bool has_end_point() const;
  inline void clear_end_point();
  static const int kEndPointFieldNumber = 4;
  inline const ::pbcar::LocInfo& end_point() const;
  inline ::pbcar::LocInfo* mutable_end_point();
  inline ::pbcar::LocInfo* release_end_point();
  inline void set_allocated_end_point(::pbcar::LocInfo* end_point);

  // repeated int32 route = 5;
  inline int route_size() const;
  inline void clear_route();
  static const int kRouteFieldNumber = 5;
  inline ::google::protobuf::int32 route(int index) const;
  inline void set_route(int index, ::google::protobuf::int32 value);
  inline void add_route(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      route() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_route();

  // optional string sequence = 6;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 6;
  inline const ::std::string& sequence() const;
  inline void set_sequence(const ::std::string& value);
  inline void set_sequence(const char* value);
  inline void set_sequence(const char* value, size_t size);
  inline ::std::string* mutable_sequence();
  inline ::std::string* release_sequence();
  inline void set_allocated_sequence(::std::string* sequence);

  // @@protoc_insertion_point(class_scope:pbcar.ServerCmd)
 private:
  inline void set_has_cmd();
  inline void clear_has_cmd();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_start_point();
  inline void clear_has_start_point();
  inline void set_has_end_point();
  inline void clear_has_end_point();
  inline void set_has_sequence();
  inline void clear_has_sequence();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 timestamp_;
  ::pbcar::LocInfo* start_point_;
  ::pbcar::LocInfo* end_point_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > route_;
  ::std::string* sequence_;
  ::google::protobuf::int32 cmd_;
  friend void  protobuf_AddDesc_carmsg_2eproto();
  friend void protobuf_AssignDesc_carmsg_2eproto();
  friend void protobuf_ShutdownFile_carmsg_2eproto();

  void InitAsDefaultInstance();
  static ServerCmd* default_instance_;
};
// -------------------------------------------------------------------

class DeviceResponse : public ::google::protobuf::Message {
 public:
  DeviceResponse();
  virtual ~DeviceResponse();

  DeviceResponse(const DeviceResponse& from);

  inline DeviceResponse& operator=(const DeviceResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeviceResponse& default_instance();

  void Swap(DeviceResponse* other);

  // implements Message ----------------------------------------------

  DeviceResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DeviceResponse& from);
  void MergeFrom(const DeviceResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 status_code = 1;
  inline bool has_status_code() const;
  inline void clear_status_code();
  static const int kStatusCodeFieldNumber = 1;
  inline ::google::protobuf::int32 status_code() const;
  inline void set_status_code(::google::protobuf::int32 value);

  // optional string desc = 2;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 2;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // optional string sequence = 3;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  inline const ::std::string& sequence() const;
  inline void set_sequence(const ::std::string& value);
  inline void set_sequence(const char* value);
  inline void set_sequence(const char* value, size_t size);
  inline ::std::string* mutable_sequence();
  inline ::std::string* release_sequence();
  inline void set_allocated_sequence(::std::string* sequence);

  // @@protoc_insertion_point(class_scope:pbcar.DeviceResponse)
 private:
  inline void set_has_status_code();
  inline void clear_has_status_code();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_sequence();
  inline void clear_has_sequence();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* desc_;
  ::std::string* sequence_;
  ::google::protobuf::int32 status_code_;
  friend void  protobuf_AddDesc_carmsg_2eproto();
  friend void protobuf_AssignDesc_carmsg_2eproto();
  friend void protobuf_ShutdownFile_carmsg_2eproto();

  void InitAsDefaultInstance();
  static DeviceResponse* default_instance_;
};
// -------------------------------------------------------------------

class MessageWrapper : public ::google::protobuf::Message {
 public:
  MessageWrapper();
  virtual ~MessageWrapper();

  MessageWrapper(const MessageWrapper& from);

  inline MessageWrapper& operator=(const MessageWrapper& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MessageWrapper& default_instance();

  void Swap(MessageWrapper* other);

  // implements Message ----------------------------------------------

  MessageWrapper* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MessageWrapper& from);
  void MergeFrom(const MessageWrapper& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .pbcar.ImageUpload image_upload = 1;
  inline bool has_image_upload() const;
  inline void clear_image_upload();
  static const int kImageUploadFieldNumber = 1;
  inline const ::pbcar::ImageUpload& image_upload() const;
  inline ::pbcar::ImageUpload* mutable_image_upload();
  inline ::pbcar::ImageUpload* release_image_upload();
  inline void set_allocated_image_upload(::pbcar::ImageUpload* image_upload);

  // optional .pbcar.LocUpload loc_upload = 2;
  inline bool has_loc_upload() const;
  inline void clear_loc_upload();
  static const int kLocUploadFieldNumber = 2;
  inline const ::pbcar::LocUpload& loc_upload() const;
  inline ::pbcar::LocUpload* mutable_loc_upload();
  inline ::pbcar::LocUpload* release_loc_upload();
  inline void set_allocated_loc_upload(::pbcar::LocUpload* loc_upload);

  // optional .pbcar.ServerResponse server_resp = 3;
  inline bool has_server_resp() const;
  inline void clear_server_resp();
  static const int kServerRespFieldNumber = 3;
  inline const ::pbcar::ServerResponse& server_resp() const;
  inline ::pbcar::ServerResponse* mutable_server_resp();
  inline ::pbcar::ServerResponse* release_server_resp();
  inline void set_allocated_server_resp(::pbcar::ServerResponse* server_resp);

  // optional .pbcar.ServerCmd server_cmd = 4;
  inline bool has_server_cmd() const;
  inline void clear_server_cmd();
  static const int kServerCmdFieldNumber = 4;
  inline const ::pbcar::ServerCmd& server_cmd() const;
  inline ::pbcar::ServerCmd* mutable_server_cmd();
  inline ::pbcar::ServerCmd* release_server_cmd();
  inline void set_allocated_server_cmd(::pbcar::ServerCmd* server_cmd);

  // optional .pbcar.DeviceResponse device_resp = 5;
  inline bool has_device_resp() const;
  inline void clear_device_resp();
  static const int kDeviceRespFieldNumber = 5;
  inline const ::pbcar::DeviceResponse& device_resp() const;
  inline ::pbcar::DeviceResponse* mutable_device_resp();
  inline ::pbcar::DeviceResponse* release_device_resp();
  inline void set_allocated_device_resp(::pbcar::DeviceResponse* device_resp);

  // @@protoc_insertion_point(class_scope:pbcar.MessageWrapper)
 private:
  inline void set_has_image_upload();
  inline void clear_has_image_upload();
  inline void set_has_loc_upload();
  inline void clear_has_loc_upload();
  inline void set_has_server_resp();
  inline void clear_has_server_resp();
  inline void set_has_server_cmd();
  inline void clear_has_server_cmd();
  inline void set_has_device_resp();
  inline void clear_has_device_resp();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::pbcar::ImageUpload* image_upload_;
  ::pbcar::LocUpload* loc_upload_;
  ::pbcar::ServerResponse* server_resp_;
  ::pbcar::ServerCmd* server_cmd_;
  ::pbcar::DeviceResponse* device_resp_;
  friend void  protobuf_AddDesc_carmsg_2eproto();
  friend void protobuf_AssignDesc_carmsg_2eproto();
  friend void protobuf_ShutdownFile_carmsg_2eproto();

  void InitAsDefaultInstance();
  static MessageWrapper* default_instance_;
};
// ===================================================================


// ===================================================================

// ImageUpload

// repeated bytes snapshot = 1;
inline int ImageUpload::snapshot_size() const {
  return snapshot_.size();
}
inline void ImageUpload::clear_snapshot() {
  snapshot_.Clear();
}
inline const ::std::string& ImageUpload::snapshot(int index) const {
  // @@protoc_insertion_point(field_get:pbcar.ImageUpload.snapshot)
  return snapshot_.Get(index);
}
inline ::std::string* ImageUpload::mutable_snapshot(int index) {
  // @@protoc_insertion_point(field_mutable:pbcar.ImageUpload.snapshot)
  return snapshot_.Mutable(index);
}
inline void ImageUpload::set_snapshot(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pbcar.ImageUpload.snapshot)
  snapshot_.Mutable(index)->assign(value);
}
inline void ImageUpload::set_snapshot(int index, const char* value) {
  snapshot_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pbcar.ImageUpload.snapshot)
}
inline void ImageUpload::set_snapshot(int index, const void* value, size_t size) {
  snapshot_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pbcar.ImageUpload.snapshot)
}
inline ::std::string* ImageUpload::add_snapshot() {
  return snapshot_.Add();
}
inline void ImageUpload::add_snapshot(const ::std::string& value) {
  snapshot_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pbcar.ImageUpload.snapshot)
}
inline void ImageUpload::add_snapshot(const char* value) {
  snapshot_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pbcar.ImageUpload.snapshot)
}
inline void ImageUpload::add_snapshot(const void* value, size_t size) {
  snapshot_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pbcar.ImageUpload.snapshot)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ImageUpload::snapshot() const {
  // @@protoc_insertion_point(field_list:pbcar.ImageUpload.snapshot)
  return snapshot_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ImageUpload::mutable_snapshot() {
  // @@protoc_insertion_point(field_mutable_list:pbcar.ImageUpload.snapshot)
  return &snapshot_;
}

// optional uint64 timestamp = 2;
inline bool ImageUpload::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageUpload::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageUpload::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageUpload::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 ImageUpload::timestamp() const {
  // @@protoc_insertion_point(field_get:pbcar.ImageUpload.timestamp)
  return timestamp_;
}
inline void ImageUpload::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:pbcar.ImageUpload.timestamp)
}

// optional string session = 3;
inline bool ImageUpload::has_session() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageUpload::set_has_session() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageUpload::clear_has_session() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageUpload::clear_session() {
  if (session_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_->clear();
  }
  clear_has_session();
}
inline const ::std::string& ImageUpload::session() const {
  // @@protoc_insertion_point(field_get:pbcar.ImageUpload.session)
  return *session_;
}
inline void ImageUpload::set_session(const ::std::string& value) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_ = new ::std::string;
  }
  session_->assign(value);
  // @@protoc_insertion_point(field_set:pbcar.ImageUpload.session)
}
inline void ImageUpload::set_session(const char* value) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_ = new ::std::string;
  }
  session_->assign(value);
  // @@protoc_insertion_point(field_set_char:pbcar.ImageUpload.session)
}
inline void ImageUpload::set_session(const char* value, size_t size) {
  set_has_session();
  if (session_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_ = new ::std::string;
  }
  session_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pbcar.ImageUpload.session)
}
inline ::std::string* ImageUpload::mutable_session() {
  set_has_session();
  if (session_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    session_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pbcar.ImageUpload.session)
  return session_;
}
inline ::std::string* ImageUpload::release_session() {
  clear_has_session();
  if (session_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = session_;
    session_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageUpload::set_allocated_session(::std::string* session) {
  if (session_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete session_;
  }
  if (session) {
    set_has_session();
    session_ = session;
  } else {
    clear_has_session();
    session_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pbcar.ImageUpload.session)
}

// optional string sequence = 4;
inline bool ImageUpload::has_sequence() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageUpload::set_has_sequence() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageUpload::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageUpload::clear_sequence() {
  if (sequence_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_->clear();
  }
  clear_has_sequence();
}
inline const ::std::string& ImageUpload::sequence() const {
  // @@protoc_insertion_point(field_get:pbcar.ImageUpload.sequence)
  return *sequence_;
}
inline void ImageUpload::set_sequence(const ::std::string& value) {
  set_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_ = new ::std::string;
  }
  sequence_->assign(value);
  // @@protoc_insertion_point(field_set:pbcar.ImageUpload.sequence)
}
inline void ImageUpload::set_sequence(const char* value) {
  set_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_ = new ::std::string;
  }
  sequence_->assign(value);
  // @@protoc_insertion_point(field_set_char:pbcar.ImageUpload.sequence)
}
inline void ImageUpload::set_sequence(const char* value, size_t size) {
  set_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_ = new ::std::string;
  }
  sequence_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pbcar.ImageUpload.sequence)
}
inline ::std::string* ImageUpload::mutable_sequence() {
  set_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pbcar.ImageUpload.sequence)
  return sequence_;
}
inline ::std::string* ImageUpload::release_sequence() {
  clear_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sequence_;
    sequence_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ImageUpload::set_allocated_sequence(::std::string* sequence) {
  if (sequence_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sequence_;
  }
  if (sequence) {
    set_has_sequence();
    sequence_ = sequence;
  } else {
    clear_has_sequence();
    sequence_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pbcar.ImageUpload.sequence)
}

// -------------------------------------------------------------------

// LocInfo

// optional float x = 1;
inline bool LocInfo::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LocInfo::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LocInfo::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LocInfo::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float LocInfo::x() const {
  // @@protoc_insertion_point(field_get:pbcar.LocInfo.x)
  return x_;
}
inline void LocInfo::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:pbcar.LocInfo.x)
}

// optional float y = 2;
inline bool LocInfo::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocInfo::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocInfo::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocInfo::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float LocInfo::y() const {
  // @@protoc_insertion_point(field_get:pbcar.LocInfo.y)
  return y_;
}
inline void LocInfo::set_y(float value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:pbcar.LocInfo.y)
}

// optional float z = 3;
inline bool LocInfo::has_z() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocInfo::set_has_z() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocInfo::clear_has_z() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocInfo::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float LocInfo::z() const {
  // @@protoc_insertion_point(field_get:pbcar.LocInfo.z)
  return z_;
}
inline void LocInfo::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:pbcar.LocInfo.z)
}

// optional float w = 4;
inline bool LocInfo::has_w() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LocInfo::set_has_w() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LocInfo::clear_has_w() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LocInfo::clear_w() {
  w_ = 0;
  clear_has_w();
}
inline float LocInfo::w() const {
  // @@protoc_insertion_point(field_get:pbcar.LocInfo.w)
  return w_;
}
inline void LocInfo::set_w(float value) {
  set_has_w();
  w_ = value;
  // @@protoc_insertion_point(field_set:pbcar.LocInfo.w)
}

// -------------------------------------------------------------------

// LocUpload

// repeated .pbcar.LocInfo location = 1;
inline int LocUpload::location_size() const {
  return location_.size();
}
inline void LocUpload::clear_location() {
  location_.Clear();
}
inline const ::pbcar::LocInfo& LocUpload::location(int index) const {
  // @@protoc_insertion_point(field_get:pbcar.LocUpload.location)
  return location_.Get(index);
}
inline ::pbcar::LocInfo* LocUpload::mutable_location(int index) {
  // @@protoc_insertion_point(field_mutable:pbcar.LocUpload.location)
  return location_.Mutable(index);
}
inline ::pbcar::LocInfo* LocUpload::add_location() {
  // @@protoc_insertion_point(field_add:pbcar.LocUpload.location)
  return location_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pbcar::LocInfo >&
LocUpload::location() const {
  // @@protoc_insertion_point(field_list:pbcar.LocUpload.location)
  return location_;
}
inline ::google::protobuf::RepeatedPtrField< ::pbcar::LocInfo >*
LocUpload::mutable_location() {
  // @@protoc_insertion_point(field_mutable_list:pbcar.LocUpload.location)
  return &location_;
}

// optional uint64 timestamp = 2;
inline bool LocUpload::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LocUpload::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LocUpload::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LocUpload::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 LocUpload::timestamp() const {
  // @@protoc_insertion_point(field_get:pbcar.LocUpload.timestamp)
  return timestamp_;
}
inline void LocUpload::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:pbcar.LocUpload.timestamp)
}

// optional string sequence = 3;
inline bool LocUpload::has_sequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LocUpload::set_has_sequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LocUpload::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LocUpload::clear_sequence() {
  if (sequence_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_->clear();
  }
  clear_has_sequence();
}
inline const ::std::string& LocUpload::sequence() const {
  // @@protoc_insertion_point(field_get:pbcar.LocUpload.sequence)
  return *sequence_;
}
inline void LocUpload::set_sequence(const ::std::string& value) {
  set_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_ = new ::std::string;
  }
  sequence_->assign(value);
  // @@protoc_insertion_point(field_set:pbcar.LocUpload.sequence)
}
inline void LocUpload::set_sequence(const char* value) {
  set_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_ = new ::std::string;
  }
  sequence_->assign(value);
  // @@protoc_insertion_point(field_set_char:pbcar.LocUpload.sequence)
}
inline void LocUpload::set_sequence(const char* value, size_t size) {
  set_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_ = new ::std::string;
  }
  sequence_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pbcar.LocUpload.sequence)
}
inline ::std::string* LocUpload::mutable_sequence() {
  set_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pbcar.LocUpload.sequence)
  return sequence_;
}
inline ::std::string* LocUpload::release_sequence() {
  clear_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sequence_;
    sequence_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void LocUpload::set_allocated_sequence(::std::string* sequence) {
  if (sequence_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sequence_;
  }
  if (sequence) {
    set_has_sequence();
    sequence_ = sequence;
  } else {
    clear_has_sequence();
    sequence_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pbcar.LocUpload.sequence)
}

// -------------------------------------------------------------------

// ServerResponse

// optional int32 status_code = 1;
inline bool ServerResponse::has_status_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerResponse::set_has_status_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerResponse::clear_has_status_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerResponse::clear_status_code() {
  status_code_ = 0;
  clear_has_status_code();
}
inline ::google::protobuf::int32 ServerResponse::status_code() const {
  // @@protoc_insertion_point(field_get:pbcar.ServerResponse.status_code)
  return status_code_;
}
inline void ServerResponse::set_status_code(::google::protobuf::int32 value) {
  set_has_status_code();
  status_code_ = value;
  // @@protoc_insertion_point(field_set:pbcar.ServerResponse.status_code)
}

// optional string desc = 2;
inline bool ServerResponse::has_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerResponse::set_has_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerResponse::clear_has_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerResponse::clear_desc() {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& ServerResponse::desc() const {
  // @@protoc_insertion_point(field_get:pbcar.ServerResponse.desc)
  return *desc_;
}
inline void ServerResponse::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set:pbcar.ServerResponse.desc)
}
inline void ServerResponse::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:pbcar.ServerResponse.desc)
}
inline void ServerResponse::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pbcar.ServerResponse.desc)
}
inline ::std::string* ServerResponse::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pbcar.ServerResponse.desc)
  return desc_;
}
inline ::std::string* ServerResponse::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ServerResponse::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pbcar.ServerResponse.desc)
}

// optional string sequence = 3;
inline bool ServerResponse::has_sequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerResponse::set_has_sequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerResponse::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerResponse::clear_sequence() {
  if (sequence_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_->clear();
  }
  clear_has_sequence();
}
inline const ::std::string& ServerResponse::sequence() const {
  // @@protoc_insertion_point(field_get:pbcar.ServerResponse.sequence)
  return *sequence_;
}
inline void ServerResponse::set_sequence(const ::std::string& value) {
  set_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_ = new ::std::string;
  }
  sequence_->assign(value);
  // @@protoc_insertion_point(field_set:pbcar.ServerResponse.sequence)
}
inline void ServerResponse::set_sequence(const char* value) {
  set_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_ = new ::std::string;
  }
  sequence_->assign(value);
  // @@protoc_insertion_point(field_set_char:pbcar.ServerResponse.sequence)
}
inline void ServerResponse::set_sequence(const char* value, size_t size) {
  set_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_ = new ::std::string;
  }
  sequence_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pbcar.ServerResponse.sequence)
}
inline ::std::string* ServerResponse::mutable_sequence() {
  set_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pbcar.ServerResponse.sequence)
  return sequence_;
}
inline ::std::string* ServerResponse::release_sequence() {
  clear_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sequence_;
    sequence_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ServerResponse::set_allocated_sequence(::std::string* sequence) {
  if (sequence_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sequence_;
  }
  if (sequence) {
    set_has_sequence();
    sequence_ = sequence;
  } else {
    clear_has_sequence();
    sequence_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pbcar.ServerResponse.sequence)
}

// -------------------------------------------------------------------

// ServerCmd

// optional int32 cmd = 1;
inline bool ServerCmd::has_cmd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServerCmd::set_has_cmd() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServerCmd::clear_has_cmd() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServerCmd::clear_cmd() {
  cmd_ = 0;
  clear_has_cmd();
}
inline ::google::protobuf::int32 ServerCmd::cmd() const {
  // @@protoc_insertion_point(field_get:pbcar.ServerCmd.cmd)
  return cmd_;
}
inline void ServerCmd::set_cmd(::google::protobuf::int32 value) {
  set_has_cmd();
  cmd_ = value;
  // @@protoc_insertion_point(field_set:pbcar.ServerCmd.cmd)
}

// optional uint64 timestamp = 2;
inline bool ServerCmd::has_timestamp() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServerCmd::set_has_timestamp() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServerCmd::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServerCmd::clear_timestamp() {
  timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_timestamp();
}
inline ::google::protobuf::uint64 ServerCmd::timestamp() const {
  // @@protoc_insertion_point(field_get:pbcar.ServerCmd.timestamp)
  return timestamp_;
}
inline void ServerCmd::set_timestamp(::google::protobuf::uint64 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:pbcar.ServerCmd.timestamp)
}

// optional .pbcar.LocInfo start_point = 3;
inline bool ServerCmd::has_start_point() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ServerCmd::set_has_start_point() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ServerCmd::clear_has_start_point() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ServerCmd::clear_start_point() {
  if (start_point_ != NULL) start_point_->::pbcar::LocInfo::Clear();
  clear_has_start_point();
}
inline const ::pbcar::LocInfo& ServerCmd::start_point() const {
  // @@protoc_insertion_point(field_get:pbcar.ServerCmd.start_point)
  return start_point_ != NULL ? *start_point_ : *default_instance_->start_point_;
}
inline ::pbcar::LocInfo* ServerCmd::mutable_start_point() {
  set_has_start_point();
  if (start_point_ == NULL) start_point_ = new ::pbcar::LocInfo;
  // @@protoc_insertion_point(field_mutable:pbcar.ServerCmd.start_point)
  return start_point_;
}
inline ::pbcar::LocInfo* ServerCmd::release_start_point() {
  clear_has_start_point();
  ::pbcar::LocInfo* temp = start_point_;
  start_point_ = NULL;
  return temp;
}
inline void ServerCmd::set_allocated_start_point(::pbcar::LocInfo* start_point) {
  delete start_point_;
  start_point_ = start_point;
  if (start_point) {
    set_has_start_point();
  } else {
    clear_has_start_point();
  }
  // @@protoc_insertion_point(field_set_allocated:pbcar.ServerCmd.start_point)
}

// optional .pbcar.LocInfo end_point = 4;
inline bool ServerCmd::has_end_point() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ServerCmd::set_has_end_point() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ServerCmd::clear_has_end_point() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ServerCmd::clear_end_point() {
  if (end_point_ != NULL) end_point_->::pbcar::LocInfo::Clear();
  clear_has_end_point();
}
inline const ::pbcar::LocInfo& ServerCmd::end_point() const {
  // @@protoc_insertion_point(field_get:pbcar.ServerCmd.end_point)
  return end_point_ != NULL ? *end_point_ : *default_instance_->end_point_;
}
inline ::pbcar::LocInfo* ServerCmd::mutable_end_point() {
  set_has_end_point();
  if (end_point_ == NULL) end_point_ = new ::pbcar::LocInfo;
  // @@protoc_insertion_point(field_mutable:pbcar.ServerCmd.end_point)
  return end_point_;
}
inline ::pbcar::LocInfo* ServerCmd::release_end_point() {
  clear_has_end_point();
  ::pbcar::LocInfo* temp = end_point_;
  end_point_ = NULL;
  return temp;
}
inline void ServerCmd::set_allocated_end_point(::pbcar::LocInfo* end_point) {
  delete end_point_;
  end_point_ = end_point;
  if (end_point) {
    set_has_end_point();
  } else {
    clear_has_end_point();
  }
  // @@protoc_insertion_point(field_set_allocated:pbcar.ServerCmd.end_point)
}

// repeated int32 route = 5;
inline int ServerCmd::route_size() const {
  return route_.size();
}
inline void ServerCmd::clear_route() {
  route_.Clear();
}
inline ::google::protobuf::int32 ServerCmd::route(int index) const {
  // @@protoc_insertion_point(field_get:pbcar.ServerCmd.route)
  return route_.Get(index);
}
inline void ServerCmd::set_route(int index, ::google::protobuf::int32 value) {
  route_.Set(index, value);
  // @@protoc_insertion_point(field_set:pbcar.ServerCmd.route)
}
inline void ServerCmd::add_route(::google::protobuf::int32 value) {
  route_.Add(value);
  // @@protoc_insertion_point(field_add:pbcar.ServerCmd.route)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
ServerCmd::route() const {
  // @@protoc_insertion_point(field_list:pbcar.ServerCmd.route)
  return route_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
ServerCmd::mutable_route() {
  // @@protoc_insertion_point(field_mutable_list:pbcar.ServerCmd.route)
  return &route_;
}

// optional string sequence = 6;
inline bool ServerCmd::has_sequence() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ServerCmd::set_has_sequence() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ServerCmd::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ServerCmd::clear_sequence() {
  if (sequence_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_->clear();
  }
  clear_has_sequence();
}
inline const ::std::string& ServerCmd::sequence() const {
  // @@protoc_insertion_point(field_get:pbcar.ServerCmd.sequence)
  return *sequence_;
}
inline void ServerCmd::set_sequence(const ::std::string& value) {
  set_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_ = new ::std::string;
  }
  sequence_->assign(value);
  // @@protoc_insertion_point(field_set:pbcar.ServerCmd.sequence)
}
inline void ServerCmd::set_sequence(const char* value) {
  set_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_ = new ::std::string;
  }
  sequence_->assign(value);
  // @@protoc_insertion_point(field_set_char:pbcar.ServerCmd.sequence)
}
inline void ServerCmd::set_sequence(const char* value, size_t size) {
  set_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_ = new ::std::string;
  }
  sequence_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pbcar.ServerCmd.sequence)
}
inline ::std::string* ServerCmd::mutable_sequence() {
  set_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pbcar.ServerCmd.sequence)
  return sequence_;
}
inline ::std::string* ServerCmd::release_sequence() {
  clear_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sequence_;
    sequence_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void ServerCmd::set_allocated_sequence(::std::string* sequence) {
  if (sequence_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sequence_;
  }
  if (sequence) {
    set_has_sequence();
    sequence_ = sequence;
  } else {
    clear_has_sequence();
    sequence_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pbcar.ServerCmd.sequence)
}

// -------------------------------------------------------------------

// DeviceResponse

// optional int32 status_code = 1;
inline bool DeviceResponse::has_status_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeviceResponse::set_has_status_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeviceResponse::clear_has_status_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeviceResponse::clear_status_code() {
  status_code_ = 0;
  clear_has_status_code();
}
inline ::google::protobuf::int32 DeviceResponse::status_code() const {
  // @@protoc_insertion_point(field_get:pbcar.DeviceResponse.status_code)
  return status_code_;
}
inline void DeviceResponse::set_status_code(::google::protobuf::int32 value) {
  set_has_status_code();
  status_code_ = value;
  // @@protoc_insertion_point(field_set:pbcar.DeviceResponse.status_code)
}

// optional string desc = 2;
inline bool DeviceResponse::has_desc() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeviceResponse::set_has_desc() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeviceResponse::clear_has_desc() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeviceResponse::clear_desc() {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& DeviceResponse::desc() const {
  // @@protoc_insertion_point(field_get:pbcar.DeviceResponse.desc)
  return *desc_;
}
inline void DeviceResponse::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set:pbcar.DeviceResponse.desc)
}
inline void DeviceResponse::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:pbcar.DeviceResponse.desc)
}
inline void DeviceResponse::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pbcar.DeviceResponse.desc)
}
inline ::std::string* DeviceResponse::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pbcar.DeviceResponse.desc)
  return desc_;
}
inline ::std::string* DeviceResponse::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DeviceResponse::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pbcar.DeviceResponse.desc)
}

// optional string sequence = 3;
inline bool DeviceResponse::has_sequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeviceResponse::set_has_sequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeviceResponse::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeviceResponse::clear_sequence() {
  if (sequence_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_->clear();
  }
  clear_has_sequence();
}
inline const ::std::string& DeviceResponse::sequence() const {
  // @@protoc_insertion_point(field_get:pbcar.DeviceResponse.sequence)
  return *sequence_;
}
inline void DeviceResponse::set_sequence(const ::std::string& value) {
  set_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_ = new ::std::string;
  }
  sequence_->assign(value);
  // @@protoc_insertion_point(field_set:pbcar.DeviceResponse.sequence)
}
inline void DeviceResponse::set_sequence(const char* value) {
  set_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_ = new ::std::string;
  }
  sequence_->assign(value);
  // @@protoc_insertion_point(field_set_char:pbcar.DeviceResponse.sequence)
}
inline void DeviceResponse::set_sequence(const char* value, size_t size) {
  set_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_ = new ::std::string;
  }
  sequence_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pbcar.DeviceResponse.sequence)
}
inline ::std::string* DeviceResponse::mutable_sequence() {
  set_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    sequence_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:pbcar.DeviceResponse.sequence)
  return sequence_;
}
inline ::std::string* DeviceResponse::release_sequence() {
  clear_has_sequence();
  if (sequence_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = sequence_;
    sequence_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void DeviceResponse::set_allocated_sequence(::std::string* sequence) {
  if (sequence_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete sequence_;
  }
  if (sequence) {
    set_has_sequence();
    sequence_ = sequence;
  } else {
    clear_has_sequence();
    sequence_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:pbcar.DeviceResponse.sequence)
}

// -------------------------------------------------------------------

// MessageWrapper

// optional .pbcar.ImageUpload image_upload = 1;
inline bool MessageWrapper::has_image_upload() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MessageWrapper::set_has_image_upload() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MessageWrapper::clear_has_image_upload() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MessageWrapper::clear_image_upload() {
  if (image_upload_ != NULL) image_upload_->::pbcar::ImageUpload::Clear();
  clear_has_image_upload();
}
inline const ::pbcar::ImageUpload& MessageWrapper::image_upload() const {
  // @@protoc_insertion_point(field_get:pbcar.MessageWrapper.image_upload)
  return image_upload_ != NULL ? *image_upload_ : *default_instance_->image_upload_;
}
inline ::pbcar::ImageUpload* MessageWrapper::mutable_image_upload() {
  set_has_image_upload();
  if (image_upload_ == NULL) image_upload_ = new ::pbcar::ImageUpload;
  // @@protoc_insertion_point(field_mutable:pbcar.MessageWrapper.image_upload)
  return image_upload_;
}
inline ::pbcar::ImageUpload* MessageWrapper::release_image_upload() {
  clear_has_image_upload();
  ::pbcar::ImageUpload* temp = image_upload_;
  image_upload_ = NULL;
  return temp;
}
inline void MessageWrapper::set_allocated_image_upload(::pbcar::ImageUpload* image_upload) {
  delete image_upload_;
  image_upload_ = image_upload;
  if (image_upload) {
    set_has_image_upload();
  } else {
    clear_has_image_upload();
  }
  // @@protoc_insertion_point(field_set_allocated:pbcar.MessageWrapper.image_upload)
}

// optional .pbcar.LocUpload loc_upload = 2;
inline bool MessageWrapper::has_loc_upload() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MessageWrapper::set_has_loc_upload() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MessageWrapper::clear_has_loc_upload() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MessageWrapper::clear_loc_upload() {
  if (loc_upload_ != NULL) loc_upload_->::pbcar::LocUpload::Clear();
  clear_has_loc_upload();
}
inline const ::pbcar::LocUpload& MessageWrapper::loc_upload() const {
  // @@protoc_insertion_point(field_get:pbcar.MessageWrapper.loc_upload)
  return loc_upload_ != NULL ? *loc_upload_ : *default_instance_->loc_upload_;
}
inline ::pbcar::LocUpload* MessageWrapper::mutable_loc_upload() {
  set_has_loc_upload();
  if (loc_upload_ == NULL) loc_upload_ = new ::pbcar::LocUpload;
  // @@protoc_insertion_point(field_mutable:pbcar.MessageWrapper.loc_upload)
  return loc_upload_;
}
inline ::pbcar::LocUpload* MessageWrapper::release_loc_upload() {
  clear_has_loc_upload();
  ::pbcar::LocUpload* temp = loc_upload_;
  loc_upload_ = NULL;
  return temp;
}
inline void MessageWrapper::set_allocated_loc_upload(::pbcar::LocUpload* loc_upload) {
  delete loc_upload_;
  loc_upload_ = loc_upload;
  if (loc_upload) {
    set_has_loc_upload();
  } else {
    clear_has_loc_upload();
  }
  // @@protoc_insertion_point(field_set_allocated:pbcar.MessageWrapper.loc_upload)
}

// optional .pbcar.ServerResponse server_resp = 3;
inline bool MessageWrapper::has_server_resp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MessageWrapper::set_has_server_resp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MessageWrapper::clear_has_server_resp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MessageWrapper::clear_server_resp() {
  if (server_resp_ != NULL) server_resp_->::pbcar::ServerResponse::Clear();
  clear_has_server_resp();
}
inline const ::pbcar::ServerResponse& MessageWrapper::server_resp() const {
  // @@protoc_insertion_point(field_get:pbcar.MessageWrapper.server_resp)
  return server_resp_ != NULL ? *server_resp_ : *default_instance_->server_resp_;
}
inline ::pbcar::ServerResponse* MessageWrapper::mutable_server_resp() {
  set_has_server_resp();
  if (server_resp_ == NULL) server_resp_ = new ::pbcar::ServerResponse;
  // @@protoc_insertion_point(field_mutable:pbcar.MessageWrapper.server_resp)
  return server_resp_;
}
inline ::pbcar::ServerResponse* MessageWrapper::release_server_resp() {
  clear_has_server_resp();
  ::pbcar::ServerResponse* temp = server_resp_;
  server_resp_ = NULL;
  return temp;
}
inline void MessageWrapper::set_allocated_server_resp(::pbcar::ServerResponse* server_resp) {
  delete server_resp_;
  server_resp_ = server_resp;
  if (server_resp) {
    set_has_server_resp();
  } else {
    clear_has_server_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:pbcar.MessageWrapper.server_resp)
}

// optional .pbcar.ServerCmd server_cmd = 4;
inline bool MessageWrapper::has_server_cmd() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MessageWrapper::set_has_server_cmd() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MessageWrapper::clear_has_server_cmd() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MessageWrapper::clear_server_cmd() {
  if (server_cmd_ != NULL) server_cmd_->::pbcar::ServerCmd::Clear();
  clear_has_server_cmd();
}
inline const ::pbcar::ServerCmd& MessageWrapper::server_cmd() const {
  // @@protoc_insertion_point(field_get:pbcar.MessageWrapper.server_cmd)
  return server_cmd_ != NULL ? *server_cmd_ : *default_instance_->server_cmd_;
}
inline ::pbcar::ServerCmd* MessageWrapper::mutable_server_cmd() {
  set_has_server_cmd();
  if (server_cmd_ == NULL) server_cmd_ = new ::pbcar::ServerCmd;
  // @@protoc_insertion_point(field_mutable:pbcar.MessageWrapper.server_cmd)
  return server_cmd_;
}
inline ::pbcar::ServerCmd* MessageWrapper::release_server_cmd() {
  clear_has_server_cmd();
  ::pbcar::ServerCmd* temp = server_cmd_;
  server_cmd_ = NULL;
  return temp;
}
inline void MessageWrapper::set_allocated_server_cmd(::pbcar::ServerCmd* server_cmd) {
  delete server_cmd_;
  server_cmd_ = server_cmd;
  if (server_cmd) {
    set_has_server_cmd();
  } else {
    clear_has_server_cmd();
  }
  // @@protoc_insertion_point(field_set_allocated:pbcar.MessageWrapper.server_cmd)
}

// optional .pbcar.DeviceResponse device_resp = 5;
inline bool MessageWrapper::has_device_resp() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MessageWrapper::set_has_device_resp() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MessageWrapper::clear_has_device_resp() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MessageWrapper::clear_device_resp() {
  if (device_resp_ != NULL) device_resp_->::pbcar::DeviceResponse::Clear();
  clear_has_device_resp();
}
inline const ::pbcar::DeviceResponse& MessageWrapper::device_resp() const {
  // @@protoc_insertion_point(field_get:pbcar.MessageWrapper.device_resp)
  return device_resp_ != NULL ? *device_resp_ : *default_instance_->device_resp_;
}
inline ::pbcar::DeviceResponse* MessageWrapper::mutable_device_resp() {
  set_has_device_resp();
  if (device_resp_ == NULL) device_resp_ = new ::pbcar::DeviceResponse;
  // @@protoc_insertion_point(field_mutable:pbcar.MessageWrapper.device_resp)
  return device_resp_;
}
inline ::pbcar::DeviceResponse* MessageWrapper::release_device_resp() {
  clear_has_device_resp();
  ::pbcar::DeviceResponse* temp = device_resp_;
  device_resp_ = NULL;
  return temp;
}
inline void MessageWrapper::set_allocated_device_resp(::pbcar::DeviceResponse* device_resp) {
  delete device_resp_;
  device_resp_ = device_resp;
  if (device_resp) {
    set_has_device_resp();
  } else {
    clear_has_device_resp();
  }
  // @@protoc_insertion_point(field_set_allocated:pbcar.MessageWrapper.device_resp)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pbcar

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_carmsg_2eproto__INCLUDED
